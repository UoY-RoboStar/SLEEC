/*
 * generated by Xtext 2.25.0
 */
package circus.robocalc.sleec.tests

import circus.robocalc.sleec.sLEEC.Specification
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import java.nio.file.Files
import java.nio.file.Paths
import circus.robocalc.sleec.sLEEC.SLEECPackage

// import java.io.File
// import org.junit.Assert

@ExtendWith(InjectionExtension)
@InjectWith(SLEECInjectorProvider)
class SLEECParsingTest {
	@Inject ParseHelper<Specification> parseHelper
	@Inject ValidationTestHelper validationTestHelper
	
	val path = '../circus.robocalc.sleec.runtime/src/'
		
	
	// --------- individual SLEEC rule tests --------------
	
	@Test
	def void test_basic() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'basic.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_within() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'within.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_trigger() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'trigger.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_boolean() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'boolean.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_bool_op() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'bool_op.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_not_expr() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'not_expr.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_not_numeric() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'numeric.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_rel_op() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'rel_op.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_const() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'const.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_scale() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'scale.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_precidence() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'precidence.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_otherwise() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'otherwise.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_not_response() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'not_response.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_defeaters() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'defeaters.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_complex() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'complex.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_comment() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'comment.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_time_unit() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'time_unit.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	

	
	@Test
	def void test_redundant() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'redundant.sleec'))
		)
		validationTestHelper.assertNoIssues(result)
	}
	
	@Test
	def void test_redundant_warnings() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'redundant_warnings.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R3, under R2.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R1, under R0.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R4, under R5.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R7, under R6.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R10, under R11.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R13, under R12.')
		validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R14, under R15.')
//		try {
//					validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R8, under R9.')
//		} catch (org.junit.ComparisonFailure e){
//			validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R9, under R8.')
//		}
	}
	
	@Test
	def void test_experiment() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'experiment.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
		
//		try {
//			validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R11, under R10')
//		}			
//		catch (org.junit.ComparisonFailure e){
//			validationTestHelper.assertWarning(result, SLEECPackage.Literals.RULE, null, 'Redundant rule: R10, under R11')
//		}
	}
	
	@Test
	def void test_conflict_error() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'conflict_error.sleec'))
		)
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R12 conflicts with R13.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R13 conflicts with R12.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R8 conflicts with R9.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R9 conflicts with R8.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R0 conflicts with R1.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.RULE, null, 'R1 conflicts with R0.')
	}
	
	@Test
	def void test_invalid_var_names() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'invalid_var_names.sleec'))
		)
		validationTestHelper.assertError(result, SLEECPackage.Literals.DEFINITION, null, 'Invalid variable name: STOP.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.DEFINITION, null, 'Invalid variable name: P.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.DEFINITION, null, 'Invalid variable name: Q.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.DEFINITION, null, 'Invalid variable name: c.')
		validationTestHelper.assertError(result, SLEECPackage.Literals.DEFINITION, null, 'Invalid variable name: d.')

	}
	
	@Test
	def void test_example(){
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'example.sleec'))
		)
		validationTestHelper.assertNoIssues(result)
	}
	
	//------------------- case studies ------------------------------
	
	@Test
	def void test_firefighter_case_study() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'firefighter.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
	
	@Test
	def void test_dressing_case_study() {
		val result = parseHelper.parse(
			Files.readString(Paths.get(path + 'dressing.sleec'))
		)
		validationTestHelper.assertNoErrors(result)
	}
}
